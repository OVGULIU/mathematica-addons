(* -*- mode: math; tab-width: 3; -*- *)

(*
	* $Log$
	* Revision 1.1  1998/04/27 04:33:45  aking
	* Initial revision
	*
*)

BeginPackage["NormalForm`", {"Frechet`", "Taylor`"}]

Unprotect[NormalForm, Semisimple, ForwardAdjointAction, BackwardAdjointAction,
	FunctionNormalForm, ForwardAction, BackwardAction, LieBracket, Jordan, 
	VFTransform, Complexification, Realification, Expon, Generator, ResonanceTest]

NormalForm::usage = "{Y,U} = NormalForm[X,vars,order] reduces the vector\
	field X to its normal form using a Lie Transform method.  It is assumed\
	that the linear part of the vector field X is in Jordan normal form.\
	Y is the normalized vector field and U the generator of the inverse of the\
	normalizing transformation.  Thus if u is the transformation generated by\
	U, (i.e., u = ForwardAction[vars,U,vars,order]), we have Du . X = Y o u,\
	and, if v = BackwardAction[vars,U,vars,order], then Dv . Y = X o v."

Options[NormalForm] = {Semisimple -> True, ResonanceTest -> Identity}

NormalForm::shape = "Incommensurate dimensions: Length[X] = `1` =!= `2` =\
	Length[vars]."

Semisimple::usage = "Semisimple is an option for NormalForm.  If the linear\
	part of the vector field to be reduced is nonsemisimple (i.e., it has\
	a nilpotent part) use Semisimple -> False."

ResonanceTest::usage = "ResonanceTest is an option for NormalForm, which gives a function\
	to be applied to coefficients to determine whether they should be considered\
	equal to zero.  The default is Identity."

ForwardAdjointAction::usage = "ForwardAdjointAction[X,U,vars,n] computes the\
	action of the generating vector field U upon the vector field X in variables\
	vars to order n.  Thus, if u is generated by U and\
	Y = ForwardAdjointAction[X,U,vars,n] then Du . Y = X o u."

BackwardAdjointAction::usage = "BackwardAdjointAction[X,U,vars,n] computes the\
	reverse action of the generating vector field U upon the vector field X in\
	variables vars to order n.  Thus, if u is generated by U and\
	Y = BackwardAdjointAction[X,U,vars,n] then Du . X = Y o u."

FunctionNormalForm::usage = "{G,U} = NormalForm[F,vars,order] reduces the\
	function F in variables vars to its normal form using a Lie transform\
	method.  It is assumed that the linear part of the function F is in\
	Jordan normal form.  G is the normalized function and U the generator\
	of the inverse of the normalizing transformation.  Thus if u is the\
	transformation generated by U, (i.e., u = ForwardAction[vars,U,vars,order]),\
	we have F = G o u, and, if v = BackwardAction[vars,U,vars,order], then\
	G = F o v."

ForwardAction::usage = "ForwardAction[f,U,vars,n] computes the action of the\
	generating vector field U on the function f of variables vars to order n.\
	Thus, if u is generated by U and g = ForwardAction[f,U,vars,n], then\
	g = f o u.  In particular, to obtain u itself, note that u = Id o u, whence\
	u = ForwardAction[vars,U,vars,n]."

BackwardAction::usage = "BackwardAction[f,U,vars,n] computes the reverse action\
	of the generating vector field U on the function f of variables vars to order\
	n.  Thus, if u is generated by U and g = BackwardAction[f,U,vars,n], then\
	g o u = f.  In particular, to obtain the inverse of u, u^-1, note that\
	(u^-1) o u = Id, whence u^-1 = BackwardAction[vars,U,vars,n]."

LieBracket::usage = "LieBracket[X,Y,vars] is the Lie bracket of the vector\
	fields X and Y in the variables vars: [X,Y] = DX.Y - DY.X"

Jordan::usage = "{Y,f,g} = Jordan[X,oldvars,newvars] transforms the vector\
	field X so that its linear part is in Jordan normal form.  Y will be the\
	normalized vector field, f a linear change of variables such that\
	Df . Y = X o f, and g the inverse transformation, i.e., Dg . X = Y o g."
	
VFTransform::usage = "VFTransform[X,oldvars,f,newvars] transforms the vector\
	field X in oldvars by the coordinate transformation f by means of direct\
	substitution.  Thus, if Y = VFTransform[X,x,f,y], then Y = (D(f^-1).X) o f.\
	VFTransform[X,oldvars,f,newvars,n] gives the result to order n in newvars."

Complexification::usage = "Complexification[w,z] gives the complexifying\
	transformation {(w + z)/2, -I (w - z)/2}, where z is to be interpreted\
	as Conjugate[w]."

Realification::usage = "Realification[x,y] gives the realifying\
	transformation {x + I y, x - I y}."

Expon::usage = "Expon[X, vars, t, n], where X is a vector field in vars,\
	is Exp[t X] to order n."

Generator::usage = "Generator[f, vars, n], where f is a formal\
	diffeomorphism with linear part equal to the identity, is the vector\
	field in vars which generates f."

Begin["Private`"]

(* NormalForm[X,vars,order] reduces the vector field X to its normal form
	using a Lie Transform method.  It is assumed that the linear part of the
	vector field X is in Jordan normal form.                                 *)

NormalForm[X_List, vars_List, order_Integer, opts___] := Block[
	{$RecursionLimit = Infinity},
	Module[{F,Xe,A,Y,eps,lambda,lieSolve,zeroTest},
		If[ Length[X] != Length[vars], 
			Message[NormalForm::shape, Length[X], Length[vars]];
			Return[$Failed]
		];
		lieSolve = If[Semisimple /. {opts} /. Options[NormalForm],
			FieldSSSolve,
			FieldNilSolve
		];
		zeroTest = ResonanceTest /. {opts} /. Options[NormalForm];
		Xe = Expand[X /. Thread[vars -> eps vars]];
		A = Coefficient[Xe, eps, 1];
		lambda = eigenvalues[A, vars];
		F[0, m_Integer] := F[0,m] = m! Coefficient[Xe, eps, m+1];
		F[i_Integer/;(i > 0), m_Integer] := F[i,m] = Expand[
			F[i-1,m+1] + Sum[
				Binomial[i-1,j] LieBracket[ Y[j], F[i-j-1,m], vars],
				{j,0,i-1}
			]
		];
		For[ i = 0, i < order-1, i++,
			{F[i+1,0], Y[i]} = lieSolve[
				A, lambda,
				Expand[
					F[i,1] + Sum[
						Binomial[i,j] LieBracket[Y[j], F[i-j,0], vars],
						{j,0,i-1}
					],
				],
				vars, i+1, zeroTest
			]
		];
		List[
			Expand[ Sum[ F[i,0] / i!, {i,0,order-1}] ],
			Expand[ Sum[ Y[i] / i!, {i,0,order-2}] ]
		]
	]
]

(* ForwardAdjointAction[X,Y,vars,order] calculates the action of the
	nilpotent vector field Y upon X.  That is, if 
			dy(x,e)/de = Y(y(x,e),e), and 
		Z = ForwardAdjointAction[X,Y,vars,order],
			then Z = ((Dy^(-1) X) o y).                               *)

ForwardAdjointAction[X_List, Y_List, vars_List, order_Integer] := 
	Module[{F,Xe,Ye,U,eps},
		Xe = Expand[X /. Thread[vars -> eps vars]];
		Ye = Expand[Y /. Thread[vars -> eps vars]];
		U[i_Integer] := U[i] = i! Coefficient[Ye, eps, i+2];
		F[i_Integer,0] := F[i,0] = i! Coefficient[Xe, eps, i+1];
		F[i_Integer, m_Integer/;(m > 0)] := F[i,m] = Expand[
			F[i+1,m-1] + Sum[ 
				Binomial[i,j] LieBracket[F[i-j,m-1], U[j], vars], 
				{j,0,i}
			]
		];
		Expand[ Sum[ F[0,m] / m!, {m,0,order-1}] ]
	]

(* BackwardAdjointAction[X,Y,vars,order] calculates the vector field
	Z such that the (forward) action of the nilpotent vector field Y 
	upon Z is X.                                                       *)

BackwardAdjointAction[X_List, Y_List, vars_List, order_Integer] := 
	Module[{F,Xe,Ye,U,eps},
		Xe = Expand[X /. Thread[vars -> eps vars]];
		Ye = Expand[Y /. Thread[vars -> eps vars]];
		U[i_Integer] := U[i] = i! Coefficient[Ye, eps, i+2];
		F[0, m_Integer] := F[0,m] = m! Coefficient[Xe, eps, m+1];
		F[i_Integer/;(i > 0), m_Integer] := F[i,m] = Expand[
			F[i-1,m+1] - Sum[ 
				Binomial[i-1,j] LieBracket[F[i-j-1,m], U[j], vars], 
				{j,0,i-1}
			]
		];
		Expand[ Sum[ F[i,0] / i!, {i,0,order-1}] ]
	]

(* FunctionNormalForm[F,vars,order] reduces the function F to its normal form
	using a Lie Transform method.  It is assumed that the linear part of F
	is in Jordan normal form. *)

FunctionNormalForm[X_List, vars_List, order_Integer, opts___] := Block[
	{$RecursionLimit = Infinity},
	Module[
		{Xe,A,lambda,Y,F,eps,lieSolve},
		lieSolve = If[Semisimple /. {opts} /. Options[NormalForm],
			FunctionSSSolve,
			FunctionNilSolve
		];
		Xe = Expand[X /. Thread[vars -> eps vars]];
		A = Coefficient[Xe, eps, 1];
		lambda = eigenvalues[A, vars];
		F[0, m_Integer] := F[0,m] = m! Coefficient[Xe, eps, m+1];
		F[i_Integer/;(i > 0), m_Integer] := F[i,m] = Expand[
			F[i-1,m+1] - Sum[ 
				Binomial[i-1,j] (Frechet[F[i-j-1,m],vars] . Y[j]),
				{j,0,i-1}
			]
		];
		For[ i = 0, i < order-1, i++,
			{F[i+1,0], Y[i]} = lieSolve[
				A, lambda,
				Expand[
					F[i,1] - Sum[
						Binomial[i,j] (Frechet[F[i-j,0],vars] . Y[j]),
						{j,0,i-1}
					]
				],
				vars, i+1
			]
		];
		List[
			Expand[ Sum[ F[i,0] / i!, {i,0,order-1}] ],
			Expand[ Sum[ Y[i] / i!, {i,0,order-2}] ]
		]
	]
]


(* ForwardAction[F,Y,vars,order] calculates the action of the
	nilpotent vector field Y upon the function F.  If 
			dy(x,e)/de = Y(y(x,e),e), and 
			G = ForwardAction[F,Y,x,order], then
				G(x,e) = F(y(x,e),e).                            *)

ForwardAction[X_List, Y_List, vars_List, order_Integer] :=
	 Module[{F,Xe,Ye,U,eps},
		Xe = Expand[X /. Thread[vars -> eps vars]];
		Ye = Expand[Y /. Thread[vars -> eps vars]];
		U[i_Integer] := U[i] = i! Coefficient[Ye, eps, i+2];
		F[i_Integer,0] := F[i,0] = i! Coefficient[Xe, eps, i+1];
		F[i_Integer, m_Integer/;(m > 0)] := F[i,m] = Expand[
			F[i+1,m-1] + Sum[ 
				Binomial[i,j] (Frechet[F[i-j,m-1],vars] . U[j]),
				{j,0,i}
			]
		];
		Expand[ Sum[ F[0,m] / m!, {m,0,order-1}] ]
	]

(* BackwardAction[F,Y,vars,order] calculates the function G
	such that the action of the nilpotent vector field Y upon 
	G results in the function F.  If 
					dy(x,e)/de = Y(y(x,e),e), and 
		G = BackwardAction[F,Y,x,order], then
					F(x,e) = G(y(x,e),e).                          *)

BackwardAction[X_List, Y_List, vars_List, order_Integer] :=
	 Module[{F,Xe,Ye,U,eps},
		Xe = Expand[X /. Thread[vars -> eps vars]];
		Ye = Expand[Y /. Thread[vars -> eps vars]];
		U[i_Integer] := U[i] = i! Coefficient[Ye, eps, i+2];
		F[0, m_Integer] := F[0,m] = m! Coefficient[Xe, eps, m+1];
		F[i_Integer/;(i > 0), m_Integer] := F[i,m] = Expand[
			F[i-1,m+1] - Sum[ 
				Binomial[i-1,j] (Frechet[F[i-j-1,m],vars] . U[j]),
				{j,0,i-1}
			]
		];
		Expand[ Sum[ F[i,0] / i!, {i,0,order-1}] ]
	]

(* Generator[F,vars,order] calculates the nilpotent vector field X
	such that the action of X upon itself gives the function F.  If
				dF(x,e)/de = X(F(x,e),e), and 
		X = Generator[F,x,order], then F(x,e) = G(y(x,e),e).        *)

Generator[f_List, vars_List, n_Integer] := Module[
	{Y, eps, fe},
	If[ Length[f] != Length[vars], 
		Message[NormalForm::shape, Length[f], Length[vars]];
		Return[$Failed]
	];
	fe = f /. Thread[vars -> eps vars];
	Y[0, k_Integer] := Y[0,k] = (k+1)! Coefficient[fe, eps, k+2];
	Y[i_Integer/;(i > 0), k_Integer] := Y[i,k] = 
		Y[i-1,k+1] - Sum[
			Binomial[i-1, j] Frechet[Y[j,k], vars] . Y[i-j-1,0],
			{j,0,i-1}
		];
	Expand[Sum[ Y[i,0] / i!, {i,0,n-2}]]
]

LieBracket[X_List, Y_List, vars_List] := 
	Frechet[X,vars].Y - Frechet[Y,vars].X

(* Jordan[X,old,new] puts the linear part of the vector field X into 
	Jordan normal form, returning the normalized vector field and the
	direct and inverse linear normalizing transformations.  Thus, if
		{Y,f,g} = Jordan[X,old,new], then
			Y = (Dg . X) o f  and X = (Df . Y) o g.                    *)

Jordan[X_List, oldvars_List, newvars_List] := Module[
	{A = Frechet[Taylor[X,oldvars,1], oldvars],
		S, T, f, g, Y},
	S = First[JordanDecomposition[A]];
	T = Inverse[S];
	f = S . newvars;
	g = T . oldvars;
	Y = Expand[T . (X /. Thread[oldvars -> f])];
	{Y, f, g}
]

(* If Y = VFTransform[X,old,f,new] then Y = ((Df^-1).X) /. Thread[old -> f].
	If Y = VFTransform[X,old,f,new.n] then Y = ((Df^-1).X) /. Thread[old -> f]. 
	truncated to order n in the new variables.  										*)


VFTransform[vf_List, old_List, sub_List, new_List] := Expand[
	Inverse[Frechet[sub,new]] . (vf /. Thread[old -> sub])
]

VFTransform[vf_List, old_List, sub_List, new_List, order_Integer] := Module[
	{dsdx, ff, eps},
	ff = Taylor[vf /. Thread[old -> sub], new, order];
	dsdx = Taylor[Inverse[Frechet[sub,new]], new, order];
	Taylor[ dsdx . ff, new, order]
]

VFTransform[vf_List, old_List, sub_List, new_List, t_Symbol] := Expand[
	Inverse[Frechet[sub,new]] . ((vf /. Thread[old -> sub]) - D[sub,t])
]

VFTransform[vf_List, old_List, sub_List, new_List, t_Symbol, order_Integer] := 
	Module[{dsdx, ff, eps},
		ff = Taylor[vf /. Thread[old -> sub], new, order];
		dsdx = Taylor[Inverse[Frechet[sub,new]], new, order];
		Taylor[
			dsdx . ((vf /. Thread[old -> sub]) - D[sub,t]),
			new, order
		]
	]

(* Solve [X,Y] + G = F in the space of homogeneous polynomial vector
	fields, where X is a vector field of degree zero (i.e. linear) and
	in Jordan normal form *)

FieldSSSolve[_, eigs_List, X_List, vars_List, _, zero_] := Transpose[
	Table[
		FieldSSSolveAux[eigs, Expand[X[[i]]], vars, eigs[[i]], zero],
		{i, 1, Length[vars]}
	]
]

FieldSSSolveAux[_, 0_, _, _, _] := {0, 0}

FieldSSSolveAux[eigs_List, a_ + b_, vars_, lambda_, zero_] := 
	FieldSSSolveAux[eigs,a,vars,lambda,zero] + 
	FieldSSSolveAux[eigs,b,vars,lambda,zero]

FieldSSSolveAux[eigs_List, a_, vars_, lambda_, zero_] := 
	Module[{divisor = lambda - eigs . Exponent[a,vars]},
		If[ zero[divisor] == 0,
			{a,0},
			{0,a/divisor},
			{0,a/divisor}
		]
	]

FieldNilSolve[X_List, L_List, F_List, vars_List, deg_Integer, zero_] :=
	Module[
		{DX = Frechet[X,vars], Y, C = Monomials[deg+1,vars], 
			G, ad, n = Length[vars], i, k},
		G = unify[F,n];
		ad[f_] := ad[f] = Module[
			{g = lstfy[f,n]}, 
			unify[DX.g - Frechet[g,vars].X, n]
		];
		For[k = n, k >= 1, k--,
			For[i = 1, i <= Length[C], i++,
				Y[i,k] = diagSolve[
					Coefficient[G,C[[i]] e[k]] C[[i]], 
					vars, L, k, zero
				];
				G = Expand[G - ad[Y[i,k] e[k]]];
			]
		];
		{
			lstfy[G, n],
			lstfy[Sum[Sum[Y[i,k] e[k], {i,1,Length[C]}], {k,1,n}], n]
		}
	]

diagSolve[0, _List, _List, _Integer, _] := 0

diagSolve[f_/;(f =!= 0), vars_List, eigs_List, k_Integer, zero_] := 
Module[
	{divisor = eigs[[k]] - eigs . Exponent[f,vars]},
	If[ zero[divisor] == 0,
		0,
		f/divisor,
		f/divisor
	]
]

(* Solve A X + G = F in the space of homogeneous polynomial vector
	fields, where A is a diagonal linear operator *)

FunctionSSSolve[_, eigs_List, X_List, _, _] := Transpose[
		Table[
			FunctionSSSolveAux[Expand[X[[i]]], eigs[[i]]],
			{i, 1, Length[X]}
		]
	]

FunctionSSSolveAux[0_, _] := {0, 0}

FunctionSSSolveAux[a_ + b_, lambda_] := 
	FunctionSSSolveAux[a,lambda] + FunctionSSSolveAux[b,lambda]

FunctionSSSolveAux[a_, lambda_] := 
	If[ lambda == 0,
		{a,0},
		{0,a/lambda},
		{0,a/lambda}
	]

FunctionNilSolve[X_List, L_List, F_List, vars_List, deg_Integer] :=
	Module[
		{DX = Frechet[X,vars], Y, C = Monomials[deg+1,vars], 
			G, ad, n = Length[vars], i, k},
		G = unify[F,n];
		ad[f_] := ad[f] = Module[
			{g = lstfy[f,n]}, 
			unify[DX.g, n]
		];
		For[k = n, k >= 1, k--,
			For[i = 1, i <= Length[C], i++,
				Y[i,k] = fdiagSolve[
					Coefficient[G, C[[i]] e[k]] C[[i]], 
					L, k
				];
				G = Expand[G - ad[Y[i,k] e[k]]];
			]
		];
		{
			lstfy[G, n],
			lstfy[Sum[Sum[Y[i,k] e[k], {i,1,Length[C]}], {k,1,n}], n]
		}
	]

fdiagSolve[0, _List, _Integer] := 0

fdiagSolve[f_/;(f =!= 0), eigs_List, k_Integer] := Module[
	{divisor = eigs[[k]]},
	If[ divisor == 0,
		0,
		f/divisor,
		f/divisor
	]
]

Monomials[0, {x___}] := {1}

Monomials[order_Integer/;(order > 0), {}] := {}

Monomials[order_Integer/;(order > 0), {x_, y___}] := Flatten[
	Table[
		(x^(order-k) #)& /@ Monomials[k, {y}],
		{k,0,order}
	]
]

eigenvalues[{},{}] = {}

eigenvalues[{0, f___}, {_, r___}] := 
	Prepend[eigenvalues[{f}, {r}], 0]

eigenvalues[{(c_:1) x_, f___}, {x_, r___}] := 
	Prepend[eigenvalues[{f}, {r}], c]

eigenvalues[{(c_:1) x_ + ___, f___}, {x_, r___}] := 
	Prepend[eigenvalues[{f}, {r}], c]

eigenvalues[{_, f___}, {x_, r___}] := 
	Prepend[eigenvalues[{f},{r}], 0]

unify[G_List, n_Integer] := G . Array[e, n]

lstfy[f_, n_Integer] := Coefficient[f,#]& /@ Array[e,n]

Grade[X_, vars_List] := Module[
	{eps,Y},
	Y = X /. Thread[vars -> eps vars];
	Table[
		Coefficient[Y,eps,k],
		{k,0,Max[Exponent[Y,eps]]}
	]
]

Grade[X_, vars_List, grade_List] := Module[
	{eps,Y},
	Y = X /. Thread[vars -> (eps^grade) vars];
	Table[
		Coefficient[Y,eps,k],
		{k,0,Max[Exponent[Y,eps]]}
	]
]

Complexification[w_, z_] := {w/2 + z/2, -I w/2 + I z/2}

Realification[x_, y_] := {x + I y, x - I y}

Expon[X_List, vars_List, t_Symbol, n_Integer] := 
	Expon[t X, vars, n]

Expon[X_List, vars_List, n_Integer] := Module[
	{Y = (X . Frechet[#,vars])&},
	(NestList[Y,#,n]& /@ vars) . Table[(1 / k!), {k,0,n}]
]

End[ ]

Protect[NormalForm, Semisimple, ForwardAdjointAction, BackwardAdjointAction,
	FunctionNormalForm, ForwardAction, BackwardAction, LieBracket, Jordan, 
	VFTransform, Complexification, Realification, Expon, Generator, ResonanceTest]

EndPackage[ ]
